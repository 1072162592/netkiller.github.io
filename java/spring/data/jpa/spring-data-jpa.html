<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>第 10 章 Spring Data JPA</title><link rel="stylesheet" type="text/css" href="../../..//docbook.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="../../../index.html" title="Netkiller Java 手札" /><link rel="up" href="../../index.html" title="部分 I. Spring Framework" /><link rel="prev" href="../mongodb/mongoTemplate.Query.html" title="9.4. mongoTemplate" /><link rel="next" href="Repository.html" title="10.2. Repository" /></head><body><a xmlns="" href="//www.netkiller.cn/">Home</a> |
		<a xmlns="" href="//netkiller.github.io/">简体中文</a> |
	    <a xmlns="" href="http://netkiller.sourceforge.net/">繁体中文</a> |
	    <a xmlns="" href="/journal/index.html">杂文</a> |
	    <a xmlns="" href="//www.netkiller.cn/home/donations.html">打赏(Donations)</a> |
	    <a xmlns="" href="http://netkiller-github-com.iteye.com/">ITEYE 博客</a> |
	    <a xmlns="" href="http://my.oschina.net/neochen/">OSChina 博客</a> |
	    <a xmlns="" href="https://www.facebook.com/bg7nyt">Facebook</a> |
	    <a xmlns="" href="http://cn.linkedin.com/in/netkiller/">Linkedin</a> |
	    <a xmlns="" href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a> |
	    <a xmlns="" href="/search.html">Search</a> |
		<a xmlns="" href="mailto:netkiller@msn.com">Email</a><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 10 章 Spring Data JPA</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../mongodb/mongoTemplate.Query.html">上一页</a> </td><th width="60%" align="center">部分 I. Spring Framework</th><td width="20%" align="right"> <a accesskey="n" href="Repository.html">下一页</a></td></tr></table><hr /></div><table xmlns=""><tr><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=watch&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=fork&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;type=follow&amp;count=true&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowTransparency="true"></iframe></td></tr></table><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="spring-data-jpa"></a>第 10 章 Spring Data JPA</h2></div></div></div><div class="toc"><p><strong>目录</strong></p><dl class="toc"><dt><span class="section"><a href="spring-data-jpa.html#Entity">10.1. @Entity</a></span></dt><dd><dl><dt><span class="section"><a href="spring-data-jpa.html#id">10.1.1. @Id</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#Table">10.1.2. @Table</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#Column">10.1.3. @Column</a></span></dt><dd><dl><dt><span class="section"><a href="spring-data-jpa.html#idp300">10.1.3.1. 字段长度</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#idp301">10.1.3.2. 浮点型</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#idp302">10.1.3.3. 创建于更新控制</a></span></dt></dl></dd><dt><span class="section"><a href="spring-data-jpa.html#@NotNull">10.1.4. @NotNull 不能为空声明</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#DateTimeFormat">10.1.5. @DateTimeFormat 处理日期时间格式</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#time">10.1.6. 默认时间规则</a></span></dt><dd><dl><dt><span class="section"><a href="spring-data-jpa.html#CreatedDate">10.1.6.1. CreatedDate</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#idp303">10.1.6.2. 与时间日期有关的 hibernate 注解</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#idp304">10.1.6.3. 数据库级别的默认创建日期时间定义</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#idp305">10.1.6.4. 数据库级别的默认创建日期与更新时间定义</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#idp306">10.1.6.5. 最后修改时间</a></span></dt></dl></dd><dt><span class="section"><a href="spring-data-jpa.html#index">10.1.7. 索引</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#enum">10.1.8. Enum 枚举数据类型</a></span></dt><dd><dl><dt><span class="section"><a href="spring-data-jpa.html#idp307">10.1.8.1. 实体中处理 enum 类型</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#idp308">10.1.8.2. 数据库枚举类型</a></span></dt></dl></dd><dt><span class="section"><a href="spring-data-jpa.html#idp309">10.1.9. 整形数据类型</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#JoinColumn">10.1.10. @JoinColumn</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#OneToOne">10.1.11. @OneToOne</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#OneToMany">10.1.12. OneToMany 一对多</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#ManyToMany">10.1.13. ManyToMany 多对多</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#orphanRemoval">10.1.14. 外键级联删除</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#idp311">10.1.15. 其他</a></span></dt><dd><dl><dt><span class="section"><a href="spring-data-jpa.html#Cascade">10.1.15.1. Cascade</a></span></dt><dt><span class="section"><a href="spring-data-jpa.html#idp310">10.1.15.2. @JsonIgnore</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="Repository.html">10.2. Repository</a></span></dt><dd><dl><dt><span class="section"><a href="Repository.html#eunm">10.2.1. 传递枚举参数</a></span></dt><dt><span class="section"><a href="Repository.html#pageable">10.2.2. 翻页操作</a></span></dt><dt><span class="section"><a href="Repository.html#sort">10.2.3. 排序操作操作</a></span></dt><dt><span class="section"><a href="Repository.html#OrderBy">10.2.4. OrderBy</a></span></dt><dt><span class="section"><a href="Repository.html#Query">10.2.5. Query</a></span></dt><dd><dl><dt><span class="section"><a href="Repository.html#idp312">10.2.5.1. 参数传递</a></span></dt></dl></dd><dt><span class="section"><a href="Repository.html#Transactional">10.2.6. @Transactional</a></span></dt><dd><dl><dt><span class="section"><a href="Repository.html#idp313">10.2.6.1. 删除更新需要 @Transactional 注解</a></span></dt><dt><span class="section"><a href="Repository.html#idp314">10.2.6.2. 回滚操作</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="CrudRepository.html">10.3. CrudRepository</a></span></dt><dt><span class="section"><a href="JpaRepository.html">10.4. JpaRepository</a></span></dt><dt><span class="section"><a href="JdbcTemplate.html">10.5. JdbcTemplate</a></span></dt><dd><dl><dt><span class="section"><a href="JdbcTemplate.html#execute">10.5.1. execute</a></span></dt><dt><span class="section"><a href="JdbcTemplate.html#queryForInt">10.5.2. queryForInt</a></span></dt><dt><span class="section"><a href="JdbcTemplate.html#queryForObject">10.5.3. queryForObject</a></span></dt><dd><dl><dt><span class="section"><a href="JdbcTemplate.html#idp315">10.5.3.1. 查询 Double 类型数据库</a></span></dt></dl></dd><dt><span class="section"><a href="JdbcTemplate.html#queryForList">10.5.4. queryForList</a></span></dt></dl></dd><dt><span class="section"><a href="EntityManager.html">10.6. EntityManager</a></span></dt><dt><span class="section"><a href="faq.html">10.7. Spring Data FAQ</a></span></dt><dd><dl><dt><span class="section"><a href="faq.html#idp316">10.7.1. No identifier specified for entity</a></span></dt><dt><span class="section"><a href="faq.html#idp317">10.7.2. Oracle Date 类型显示日期和时间</a></span></dt><dt><span class="section"><a href="faq.html#idp318">10.7.3. Executing an update/delete query; nested exception is javax.persistence.TransactionRequiredException: Executing an update/delete query</a></span></dt></dl></dd></dl></div>
	
	<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Entity"></a>10.1. @Entity</h2></div></div></div>
		
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id"></a>10.1.1. @Id</h3></div></div></div>
			
			<p>ID 字段</p>
			<pre class="screen">
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "id", unique = true, nullable = false, insertable = true, updatable = false)
	private int id;
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Table"></a>10.1.2. @Table</h3></div></div></div>
			
			<p>配置Schema</p>
			<pre class="screen">
			
@Table(name="tabname", schema="public")
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Column"></a>10.1.3. @Column</h3></div></div></div>
			
			<pre class="screen">
unique		属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。
nullable		属性表示该字段是否可以为null值，默认为true。
insertable	属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。
updatable	属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。
columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。
table		属性表示当映射多个表时，指定表的表中的字段。默认值为主表的表名。
length		属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。
precision	属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。
			</pre>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp300"></a>10.1.3.1. 字段长度</h4></div></div></div>
				
				<p>字段长度定义</p>
				<pre class="screen">
				
@Column(name="name", length=80, nullable=true)	
				
				</pre>
			</div>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp301"></a>10.1.3.2. 浮点型</h4></div></div></div>
				
				<pre class="screen">
				
	@Column(precision=18, scale=5)  
    private BigDecimal principal; 	
    
    @Column(name="Price", columnDefinition="Decimal(10,2) default '100.00'")			
				
				</pre>
			</div>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp302"></a>10.1.3.3. 创建于更新控制</h4></div></div></div>
				
				<pre class="screen">
@Column(name = "ctime", nullable = false, insertable = false, updatable = false)		
				</pre>
			</div>
		</div>
		
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="@NotNull"></a>10.1.4. @NotNull 不能为空声明</h3></div></div></div>
			
			<pre class="programlisting">
@NotNull
public String username;
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="DateTimeFormat"></a>10.1.5. @DateTimeFormat 处理日期时间格式</h3></div></div></div>
			
			<pre class="programlisting">
public java.sql.Date createdate; 创建日期 YYYY-MM-DD 
public java.util.Date finisheddate; 创建日期时间 YYYY-MM-DD HH:MM:SS
			</pre>
			<p>Json默认为 yyyy-MM-ddTHH:mm:ss 注意日期与时间中间的T，修改日期格式将T去掉</p>
			<pre class="screen">
@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="time"></a>10.1.6. 默认时间规则</h3></div></div></div>
			
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="CreatedDate"></a>10.1.6.1. CreatedDate</h4></div></div></div>
				
				<p>Spring 提供了 import org.springframework.data.annotation.CreatedDate;</p>
				<p>但是这些只能作用于实体类。</p>
				<pre class="screen">
				
	@CreatedDate
    private Date createdDateTime;			
				
				</pre>
			</div>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp303"></a>10.1.6.2. 与时间日期有关的 hibernate 注解</h4></div></div></div>
				
			
			<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="hibernate.time"></a>10.1.6.2.1. 设置默认时间</h5></div></div></div>
				
				<pre class="programlisting">
				
@Column(insertable = false) 
@org.hibernate.annotations.ColumnDefault("1.00") 
@org.hibernate.annotations.Generated(
org.hibernate.annotations.GenerationTime.INSERT
) 
protected Date lastModified; 
				
				</pre>
			</div>
			<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="createTime"></a>10.1.6.2.2. 创建时间</h5></div></div></div>
				
				<pre class="programlisting">
				
@Temporal(TemporalType.TIMESTAMP)  
@Column(updatable = false)  
@org.hibernate.annotations.CreationTimestamp  
protected Date createdDate;   			
				
				</pre>
			</div>
			<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="updateTime"></a>10.1.6.2.3. 更新时间</h5></div></div></div>
				
				<pre class="programlisting">
				
@Column(name="update_time")  
@org.hibernate.annotations.UpdateTimestamp  
@Temporal(TemporalType.TIMESTAMP)
private Date updateTime;    			
				
				</pre>
				<pre class="programlisting">
				
@Temporal(TemporalType.TIMESTAMP)  
@Column(insertable = false, updatable = false)  
@org.hibernate.annotations.Generated(  
org.hibernate.annotations.GenerationTime.ALWAYS  
) 
				
				</pre>
			</div>
			</div>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp304"></a>10.1.6.3. 数据库级别的默认创建日期时间定义</h4></div></div></div>
				
				<pre class="programlisting">
				
package cn.netkiller.api.domain.elasticsearch;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table
public class ElasticsearchTrash {
	@Id
	private int id;

	@Column(columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
	private Date ctime;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public Date getCtime() {
		return ctime;
	}

	public void setCtime(Date ctime) {
		this.ctime = ctime;
	}

}				
				
				</pre>
				<p>对应数据库DDL</p>
				<pre class="programlisting">
				
CREATE TABLE `elasticsearch_trash` (
  `id` int(11) NOT NULL,
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
				
				</pre>
			</div>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp305"></a>10.1.6.4. 数据库级别的默认创建日期与更新时间定义</h4></div></div></div>
				
				<p>需求是这样的：</p>
				<p>1. 创建时间与更新时间只能由数据库产生，不允许在实体类中产生，因为每个节点的时间/时区不一定一直。另外防止人为插入自定义时间时间。</p>
				<p>2. 插入记录的时候创建默认时间，创建时间不能为空，时间一旦插入不允许日后在实体类中修改。</p>
				<p>3. 记录创建后更新日志字段为默认为 null 表示该记录没有被修改过。一旦数据被修改，修改日期字段将记录下最后的修改时间。</p>
				<p>4. 甚至你可以通过触发器实现一个history 表，用来记录数据的历史修改，详细请参考作者另一部电子书《Netkiller Architect 手札》数据库设计相关章节。</p>
				<pre class="programlisting">
				
package cn.netkiller.api.domain.elasticsearch;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.validation.constraints.Null;

@Entity
@Table
public class ElasticsearchTrash {
	@Id
	private int id;

	// 创建时间
	@Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
	private Date ctime;
	
	// 修改时间
	@Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
	private Date mtime;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public Date getCtime() {
		return ctime;
	}

	public void setCtime(Date ctime) {
		this.ctime = ctime;
	}

	public Date getMtime() {
		return mtime;
	}

	public void setMtime(Date mtime) {
		this.mtime = mtime;
	}

}		
				
				</pre>
				<p>对应数据库DDL</p>
				<pre class="programlisting">
				
CREATE TABLE `elasticsearch_trash` (
  `id` int(11) NOT NULL,
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `mtime` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
				
				</pre>
			</div>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp306"></a>10.1.6.5. 最后修改时间</h4></div></div></div>
				
				<p>需求：记录最后一次修改时间</p>
				<pre class="programlisting">
				
package cn.netkiller.api.domain.elasticsearch;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table
public class ElasticsearchTrash {
	@Id
	private int id;

	@Column(columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP")
	private Date lastModified;

}					
				
				</pre>
				<p>产生DDL语句如下</p>
				<pre class="programlisting">
				
CREATE TABLE `elasticsearch_trash` (
  `id` int(11) NOT NULL,
  `last_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;				
				
				</pre>
			</div>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="index"></a>10.1.7. 索引</h3></div></div></div>
			
			<p>针对字段做唯一索引</p>
			<pre class="screen">
@Column(unique = true)			
			</pre>
			<p>创建复合索引</p>
			<pre class="programlisting">
			
package cn.netkiller.api.model;

import java.io.Serializable;
import java.util.Date;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.UniqueConstraint;

import com.fasterxml.jackson.annotation.JsonFormat;

@Entity
@Table(name = "comment", uniqueConstraints = { @UniqueConstraint(columnNames = { "member_id", "articleId" }) })
public class Comment implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = -1484408775034277681L;
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "id", unique = true, nullable = false, insertable = true, updatable = false)
	private int id;

	@ManyToOne(cascade = { CascadeType.ALL })
	@JoinColumn(name = "member_id")
	private Member member;

	private int articleId;

	private String message;

	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	@Temporal(TemporalType.TIMESTAMP)
	@Column(updatable = false)
	@org.hibernate.annotations.CreationTimestamp
	protected Date createDate;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public Member getMember() {
		return member;
	}

	public void setMember(Member member) {
		this.member = member;
	}

	public int getArticleId() {
		return articleId;
	}

	public void setArticleId(int articleId) {
		this.articleId = articleId;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	public Date getCreateDate() {
		return createDate;
	}

	public void setCreateDate(Date createDate) {
		this.createDate = createDate;
	}
}
			
			</pre>
			<pre class="screen">
			
CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `article_id` int(11) NOT NULL,
  `create_date` datetime DEFAULT NULL,
  `message` varchar(255) DEFAULT NULL,
  `member_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK5qxfiu92nwlvgli7bl3evl11m` (`member_id`,`article_id`),
  CONSTRAINT `FKmrrrpi513ssu63i2783jyiv9m` FOREIGN KEY (`member_id`) REFERENCES `member` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="enum"></a>10.1.8. Enum 枚举数据类型</h3></div></div></div>
			
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp307"></a>10.1.8.1. 实体中处理 enum 类型</h4></div></div></div>
				
				<p>@Enumerated(value = EnumType.ORDINAL) //ORDINAL序数 </p>
				<p>在实体中处理枚举类型适用于所有数据库，Spring data 将枚举视为 String 类型。</p>
				<pre class="programlisting">
package cn.netkiller.api.domain;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "statistics_history")
public class StatisticsHistory implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "id", unique = true, nullable = false, insertable = true, updatable = false)
	private long id;
	private long memberId;
	private long statisticsId;

	public enum StatisticsType {
		LIKE, COMMENT, BROWSE;
	}

	private StatisticsType type;

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public long getMemberId() {
		return memberId;
	}

	public void setMemberId(long memberId) {
		this.memberId = memberId;
	}

	public long getStatisticsId() {
		return statisticsId;
	}

	public void setStatisticsId(long statisticsId) {
		this.statisticsId = statisticsId;
	}

	public StatisticsType getType() {
		return type;
	}

	public void setType(StatisticsType type) {
		this.type = type;
	}

}
		
				</pre>
				<p>默认 enum 类型创建数据库等效 int(11)</p>
				<pre class="programlisting">
				
CREATE TABLE `statistics_history` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `member_id` bigint(20) NOT NULL,
  `statistics_id` bigint(20) NOT NULL,
  `type` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
SELECT * FROM test.statistics;
				
				</pre>
				<p>@Enumerated(EnumType.STRING) 注解可以使其成功字符串类型。</p>
				<pre class="programlisting">
	public enum StatisticsType {
		LIKE, COMMENT, BROWSE;
	}

	@Enumerated(EnumType.STRING)
	private StatisticsType type;
				</pre>
				<p>SQL</p>
				<pre class="programlisting">
				
CREATE TABLE `statistics_history` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `member_id` bigint(20) NOT NULL,
  `statistics_id` bigint(20) NOT NULL,
  `type` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
				
				</pre>
			</div>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp308"></a>10.1.8.2. 数据库枚举类型</h4></div></div></div>
				
				<p>在枚举中处理类型虽然可以适用于所有数据库，但有时我们希望适用数据库的枚举类型（例如MySQL），数据库中得枚举类型要比字符串效率更高</p>
				<pre class="programlisting">
				
package cn.netkiller.api.domain.elasticsearch;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table
public class NetkillerTrash {
	@Id
	private int id;

	@Column(columnDefinition = "enum('Y','N') DEFAULT 'N'")
	private boolean status;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public boolean isStatus() {
		return status;
	}

	public void setStatus(boolean status) {
		this.status = status;
	}

}				
				
				</pre>
				<p>实际对应的数据库DLL</p>
				<pre class="programlisting">
				
CREATE TABLE `netkiller_trash` (
  `id` int(11) NOT NULL,
  `status` enum('Y','N') DEFAULT 'N',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
				
				</pre>
			</div>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp309"></a>10.1.9. 整形数据类型</h3></div></div></div>
			
			<p>无符号整形</p>
			<pre class="programlisting">
			
package com.example.api.domain.elasticsearch;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table
public class Member {
	@Id
	private int id;
		
	@Column(columnDefinition = "INT(10) UNSIGNED NOT NULL")
	private int age;
	
	@Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
	private Date ctime;

	@Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
	private Date mtime;

	@Column(columnDefinition = "enum('Y','N') DEFAULT 'N'")
	private boolean status;
}			
			
			</pre>
			<pre class="programlisting">
			
CREATE TABLE `member` (
  `id` int(11) NOT NULL,
  `age` int(10) unsigned NOT NULL,
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `mtime` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `status` enum('Y','N') DEFAULT 'N',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="JoinColumn"></a>10.1.10. @JoinColumn</h3></div></div></div>
			
			<p>@JoinColumn与@Column注释类似，它的定义如下代码所示。 </p>
			<pre class="screen">
			
@Target({METHOD, FIELD}) @Retention(RUNTIME) 

public @interface JoinColumn { 

String name() default ""; 

String referencedColumnName() default ""; 

boolean unique() default false; 

boolean nullable() default true; 

boolean insertable() default true; 

boolean updatable() default true; 

String columnDefinition() default ""; 

String table() default ""; 

}
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="OneToOne"></a>10.1.11. @OneToOne</h3></div></div></div>
			
			<p>一对一表结构，如下面ER图所示，users表是用户表里面有登陆信息，profile 保存的时死人信息，这样的目的是我们尽量减少users表的字段，在频繁操作该表的时候性能比较好，另外一个目的是为了横向水平扩展。</p>
			<pre class="programlisting">
			
    +----------+             +------------+
    | users    |             | profile    |
    +----------+             +------------+
    | id       | &lt;---1:1---o | id         |
    | name     |             | sex        |    
    | password |             | email      |    
    +----------+             +------------+ 
			
			</pre>
			<pre class="programlisting">
			
package cn.netkiller.api.domain.test;

import java.io.Serializable;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "users")
public class Users implements Serializable {
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String name;
	private String password;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	@Override
	public String toString() {
		return "Users [id=" + id + ", name=" + name + ", password=" + password + "]";
	}
}

			
			</pre>
			<pre class="programlisting">
			
package cn.netkiller.api.domain.test;

import java.io.Serializable;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import javax.persistence.Table;

@Entity
@Table(name = "profile")
public class Profile implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = -2500499458196257167L;
	@Id
	@OneToOne
	@JoinColumn(name = "id")
	private Users users;

	private int age;
	private String sex;
	private String email;

	public Users getUsers() {
		return users;
	}

	public void setUsers(Users users) {
		this.users = users;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getSex() {
		return sex;
	}

	public void setSex(String sex) {
		this.sex = sex;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	@Override
	public String toString() {
		return "Profile [users=" + users + ", age=" + age + ", sex=" + sex + ", email=" + email + "]";
	}

}

			
			</pre>
			<pre class="programlisting">
			
CREATE TABLE `users` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(255) NULL DEFAULT NULL,
	`password` VARCHAR(255) NULL DEFAULT NULL,
	PRIMARY KEY (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			
CREATE TABLE `profile` (
	`age` INT(11) NOT NULL,
	`email` VARCHAR(255) NULL DEFAULT NULL,
	`sex` VARCHAR(255) NULL DEFAULT NULL,
	`id` INT(11) NOT NULL,
	PRIMARY KEY (`id`),
	CONSTRAINT `FK6x079ilawxjrfsljwyyi5ujjq` FOREIGN KEY (`id`) REFERENCES `users` (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			
			</pre>
			<p>如果第二张表关联的并非主表的PK（主键）需要使用 referencedColumnName 指定。</p>
			<pre class="programlisting">
			
@JoinColumn(name = "member_id",referencedColumnName="member_id") 			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="OneToMany"></a>10.1.12. OneToMany 一对多</h3></div></div></div>
			
			<p>我们要实现一个一对多实体关系，ER 图如下</p>
			<pre class="programlisting">
			
    +----------+          +------------+
    | Classes  |          | Student    |
    +----------+          +------------+
    | id       | &lt;---+    | id         |
    | name     |     |    | name       |    
    +----------+     +--o | classes_id |    
                          +------------+ 
    
			
			</pre>
			<p>classes 表需要 OneToMany 注解，Student 表需要 ManyToOne 注解，这样就建立起了表与表之间的关系</p>
			<pre class="programlisting">
			
package cn.netkiller.api.domain.test;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;

@Entity 
@Table(name="classes") 
public class Classes implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = -5422905745519948312L;
	@Id 
	@GeneratedValue(strategy=GenerationType.AUTO) 
	private int id; 
	private String name; 
	    
	@OneToMany(cascade=CascadeType.ALL,mappedBy="classes")    
	private Set&lt;Student&gt; students;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Set&lt;Student&gt; getStudents() {
		return students;
	}

	public void setStudents(Set&lt;Student&gt; students) {
		this.students = students;
	}

	@Override
	public String toString() {
		return "classes [id=" + id + ", name=" + name + ", students=" + students + "]";
	} 
}
			
			</pre>
			<pre class="programlisting">
			
package cn.netkiller.api.domain.test;

import java.io.Serializable;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = "student")
public class Student implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = 6737037465677800326L;
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String name;

	// 若有多个cascade，可以是：{CascadeType.PERSIST,CascadeType.MERGE}
	@ManyToOne(cascade = { CascadeType.ALL })
	@JoinColumn(name = "classes_id") 
	private Classes classes;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Classes getClasses() {
		return classes;
	}

	public void setClasses(Classes classes) {
		this.classes = classes;
	}

	@Override
	public String toString() {
		return "Student [id=" + id + ", name=" + name + ", classes=" + classes + "]";
	}

}

			
			</pre>
			<p>最终 SQL 表如下</p>
			<pre class="programlisting">
			
CREATE TABLE `classes` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(255) NULL DEFAULT NULL,
	PRIMARY KEY (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;	
			
CREATE TABLE `student` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(255) NULL DEFAULT NULL,
	`class_id` INT(11) NULL DEFAULT NULL,
	PRIMARY KEY (`id`),
	INDEX `FKnsl7w2nw6o6eq53hqlxfcijpm` (`class_id`),
	CONSTRAINT `FKnsl7w2nw6o6eq53hqlxfcijpm` FOREIGN KEY (`class_id`) REFERENCES `classes` (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			
			</pre>
			<pre class="programlisting">
			
      Classes classes=new Classes(); 
      classes.setName("One"); 
        
      Student st1=new Student(); 
      st1.setSname("jason"); 
      st1.setClasses(classes); 
      studentRepostitory.save(st1); 
        
      Student st2=new Student(); 
      st2.setSname("neo"); 
      st2.setClasses(classes); 
      studentRepostitory.save(st2); 
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ManyToMany"></a>10.1.13. ManyToMany 多对多</h3></div></div></div>
			
			<p>用户与角色就是一个多对多的关系，多对多是需要中间表做关联的。所以我方需要一个 user_has_role 表。</p>
			<pre class="programlisting">
			
    +----------+          +---------------+            +--------+
    | users    |          | user_has_role |            | role   |
    +----------+          +---------------+            +--------+
    | id       | &lt;------o | user_id       |      /---&gt; | id     |
    | name     |          | role_id       | o---+      | name   |
    | password |          |               |            |        |
    +----------+          +---------------+            +--------+
			
			</pre>
			<p>创建 User 表</p>
			<pre class="programlisting">
			
package cn.netkiller.api.domain.test;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Table;
import javax.persistence.JoinColumn;

@Entity
@Table(name = "users")
public class Users implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = -2480194112597046349L;
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String name;
	private String password;

	@ManyToMany(fetch = FetchType.EAGER)
	@JoinTable(name = "user_has_role", joinColumns = { @JoinColumn(name = "user_id", referencedColumnName = "id") }, inverseJoinColumns = { @JoinColumn(name = "role_id", referencedColumnName = "id") })
	private Set&lt;Roles&gt; roles;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public Set&lt;Roles&gt; getRoles() {
		return roles;
	}

	public void setRoles(Set&lt;Roles&gt; roles) {
		this.roles = roles;
	}

	@Override
	public String toString() {
		return "Users [id=" + id + ", name=" + name + ", password=" + password + ", roles=" + roles + "]";
	}

}
			
			</pre>
			<p>创建 Role 表</p>
			<pre class="programlisting">
			
package cn.netkiller.api.domain.test;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToMany;
import javax.persistence.Table;

@Entity
@Table(name = "roles")
public class Roles implements Serializable {
	private static final long serialVersionUID = 6737037465677800326L;
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String name;
	@ManyToMany(mappedBy = "roles")
	private Set&lt;Users&gt; users;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Set&lt;Users&gt; getUsers() {
		return users;
	}

	public void setUsers(Set&lt;Users&gt; users) {
		this.users = users;
	}

	@Override
	public String toString() {
		return "Roles [id=" + id + ", name=" + name + ", users=" + users + "]";
	}

}

			
			</pre>
			<p>最终产生数据库表如下</p>
			<pre class="programlisting">
			
CREATE TABLE `users` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(255) NULL DEFAULT NULL,
	`password` VARCHAR(255) NULL DEFAULT NULL,
	PRIMARY KEY (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;	

CREATE TABLE `roles` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(255) NULL DEFAULT NULL,
	PRIMARY KEY (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			
CREATE TABLE `user_has_role` (
	`user_id` INT(11) NOT NULL,
	`role_id` INT(11) NOT NULL,
	PRIMARY KEY (`user_id`, `role_id`),
	INDEX `FKsvvq61v3koh04fycopbjx72hj` (`role_id`),
	CONSTRAINT `FK2dl1ftxlkldulcp934i3125qo` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`),
	CONSTRAINT `FKsvvq61v3koh04fycopbjx72hj` FOREIGN KEY (`role_id`) REFERENCES `roles` (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			
			</pre>
			<pre class="programlisting">
			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="orphanRemoval"></a>10.1.14. 外键级联删除</h3></div></div></div>
			
			<p>orphanRemoval = true 可以实现数据级联删除</p>
			<pre class="programlisting">
			
package cn.netkiller.api.domain;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Table;

import com.fasterxml.jackson.annotation.JsonIgnore;

@Entity
@Table(name = "member")
public class Member implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "id", unique = true, nullable = false, insertable = true, updatable = false)
	private int id;

	private String name;
	private String sex;
	private int age;
	private String wechat;

	@Column(unique = true)
	private String mobile;
	private String picture;
	private String ipAddress;

	@JsonIgnore
	@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, mappedBy = "member")
	private Set&lt;Comment&gt; comment;
	@JsonIgnore
	@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, mappedBy = "member")
	private Set&lt;StatisticsHistory&gt; statisticsHistory;

	public Member() {
	}

	public Member(int id) {
		this.id = id;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getSex() {
		return sex;
	}

	public void setSex(String sex) {
		this.sex = sex;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getWechat() {
		return wechat;
	}

	public void setWechat(String wechat) {
		this.wechat = wechat;
	}

	public String getMobile() {
		return mobile;
	}

	public void setMobile(String mobile) {
		this.mobile = mobile;
	}

	public String getPicture() {
		return picture;
	}

	public void setPicture(String picture) {
		this.picture = picture;
	}

	public String getIpAddress() {
		return ipAddress;
	}

	public void setIpAddress(String ipAddress) {
		this.ipAddress = ipAddress;
	}

	@Override
	public String toString() {
		return "Member [id=" + id + ", name=" + name + ", sex=" + sex + ", age=" + age + ", wechat=" + wechat + ", mobile=" + mobile + ", picture=" + picture + ", ipAddress=" + ipAddress + "]";
	}

}
			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp311"></a>10.1.15. 其他</h3></div></div></div>
			
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="Cascade"></a>10.1.15.1. Cascade</h4></div></div></div>
				
				<pre class="screen">
CascadeType.PERSIST （级联新建） 
CascadeType.REMOVE  （级联删除） 
CascadeType.REFRESH （级联刷新） 
CascadeType.MERGE   （级联更新）中选择一个或多个。 
CascadeType.ALL			
				</pre>
			</div>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp310"></a>10.1.15.2. @JsonIgnore</h4></div></div></div>
				
				<p>当尸体返回 Json 数据结构是，将不包含 @JsonIgnore 定义变量。</p>
				<pre class="programlisting">
				
	@JsonIgnore  
    @OneToMany(mappedBy = "owner")  
    private List&lt;Pet&gt; pets;  
				
				</pre>
			</div>
		</div>
	</div>
	
	
	
	
	
	
	
	
</div><div xmlns="" id="disqus_thread"></div><script xmlns="">

var disqus_config = function () {
this.page.url = "http://www.netkiller.cn";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'netkiller'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//netkiller.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script><noscript xmlns="">Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><br xmlns="" /><script xmlns="" type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=r5HG&amp;d=9mi5r_kkDC8uxG8HuY3p4-2qgeeVypAK9vMD-2P6BYM"></script><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="../mongodb/mongoTemplate.Query.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="../../index.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="Repository.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">9.4. mongoTemplate </td><td width="20%" align="center"><a accesskey="h" href="../../../index.html">起始页</a></td><td width="40%" align="right" valign="top"> 10.2. Repository</td></tr></table></div><script xmlns="">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-11694057-1', 'auto');
  ga('send', 'pageview');

</script><script xmlns="" async="async">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?93967759a51cda79e49bf4e34d0b0f2c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script xmlns="" async="async">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><script xmlns="" type="text/javascript" src="/js/q.js" async="async"></script></body></html>